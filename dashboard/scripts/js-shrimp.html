<!-- JavaScript -->
<script>
    let isLoading = true;
    let sensor_select = 0;

    const Sensors_realtime = ["DO", "PH", "EC", "Temp", "Salinity", "Turbidity"];
    const Sensors_name_left = ["PumpO2#1", "PumpO2#2", "PumpO2#3", "PumpO2#4", "PumpW#1", "PumpW#2"];
    const Sensors_name_right = ["Light", "Fog", "Fan", "O2", "O3", "skimRS2"];
    const market_name = "shrimp";     //name market example => solar, shrimp, indoor, outdoor
    const type = "price";             //multi type example => demand,price

    // Adjust font sizes based on screen width
    document.addEventListener('DOMContentLoaded', async () => {

        await loadSensorData();
        await SensorsLeft();
        await SensorsRight();
        await Card1();
        await Card2();
        await Card3();
        await Card4();

        await loadGraphMarketById();
        initMetricBars();
        isLoading = false;
        // setInterval(async () => {
        //     await loadSensorData();
        //     await loadGraphSensorById();
        // }, 10000);

    });

    async function loadSensorData() {
        try {
            const res = await fetch('../../api-website/plot_sensor_log_multiple.php',
                {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sensorLog: Sensors_realtime
                    })
                }
            );
            const data = await res.json();
            const sensors = data['sensors'];

            Create_sensorCard(Sensors_realtime, sensors);

            const firstKey = Sensors_realtime[0];
            sensor_select = isLoading ? sensors[firstKey].monitor_id ?? 0 : sensor_select;

            loadGraphSensorById(sensors);

        } catch (err) {
            console.error('âŒ loadSensorData error:', err);
        }
    }

    async function SensorsLeft() {
        try {
            const res = await fetch('../../api-website/plot_sensor_log_multiple.php',
                {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sensorLog: Sensors_name_left
                    })
                }
            );
            const data = await res.json();
            const sensors = data['sensors'];

            console.log("Left");
            console.log(sensors);

            SetCardsBynames(Sensors_name_left, sensors, 'left');

        } catch (err) {
            console.error('âŒ loadSensorData error:', err);
        }
    }

    async function SensorsRight() {
        try {
            const res = await fetch('../../api-website/plot_sensor_log_multiple.php',
                {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sensorLog: Sensors_name_right
                    })
                }
            );
            const data = await res.json();
            const sensors = data['sensors'];

            console.log("right");
            console.log(sensors);

            SetCardsBynames(Sensors_name_right, sensors, 'right');

        } catch (err) {
            console.error('âŒ loadSensorData error:', err);
        }
    }


    function Create_sensorCard(sensor_names, sensors) {
        let metricsCards = document.getElementById('metrics-cards');
        metricsCards.innerHTML = "";
        Object.values(sensor_names).forEach((s) => {
            const row = sensors[s] || { "min": 0, "max": 0, "unit": "--", "logs": [] };
            const min = row['min'] || 0;
            const max = row['max'] || 1;
            let value = row.logs.length > 0 ? row.logs[0].data_value : "--";
            let div = document.createElement('div');
            div.id = `card-${s}`;
            div.className = "bg-white rounded-2xl p-4 border border-stone-200 shadow-sm flex flex-col h-32 hover:ring-2 hover:ring-orange-400 transition-all duration-20 shrink-0";
            div.innerHTML = `
                <div class="w-full flex justify-between items-center">
                    <span class="text-[9px] font-bold text-stone-500 uppercase tracking-widest">
                        ${s}
                    </span>
                    <span class="px-2 py-0.5 rounded-full bg-stone-100 text-stone-500 text-[9px] font-bold uppercase status">
                        --
                    </span>
                </div>
                <div class="flex-1 flex items-center justify-center">
                    <div class="flex items-baseline gap-1">
                        <span class="text-lg font-black text-black value">
                            ${value}
                        </span>
                        <span class="text-sm font-bold text-stone-400">
                            ${row.unit}
                        </span>
                    </div>
                </div>

                <!-- Range Bar with Fixed Gradient -->
                <div class="metric-range mt-2 hidden" data-key="${s}" data-min="${min}" data-max="${max}">
                    <div class="flex justify-between text-[8px] font-bold leading-none mb-1">
                        <span class="label-left"></span>
                        <span class="label-right"></span>
                    </div>

                    <div class="relative h-1.5 rounded-full bar">
                        <div class="fill"></div>
                    </div>
                </div>
                `;

            if (row['unit'] !== "--") {
                div.onclick = () => {
                    console.log("Select sensor : " + row.monitor_name);
                    sensor_select = row.monitor_id;
                    loadGraphSensorById(sensors);
                }
            }

            metricsCards.appendChild(div);

            setCardValue(s, value, min, max);
        })
    }

    async function Card1() {
        console.log("Card 1");
        const table_type = 1;     //Watch table id in 
        try {
            const res = await fetch('../../api-website/fetch_tableByTypeId.php?typeId=' + table_type + "&aDay=" + diff.day);
            const raw = await res.json();
            const table = Object.values(raw.data);

            const mealsCount = table[0].value;
            const volumeMeal = table[0].children[0]['value'];
            const totalMealperDay = (toNumber(mealsCount) * toNumber(volumeMeal)) || "-";

            SetValueInHTMLById('meals-count', mealsCount);
            SetValueInHTMLById('volume-meal', volumeMeal);
            SetValueInHTMLById('total-meal-per-day', totalMealperDay);

        } catch (err) {
            console.error('âŒ loadSensorData error:', err);
        }
    }

    async function Card2() {
        console.log("Card 2");
        try {
            const res = await fetch('../../api-website/fetch_expenseBycategory.php?bid=1');
            const raw = await res.json();
            const expense = raw['data'];

            const electricity = Number(expense[0]?.electricity) || 0;
            const water = Number(expense[0]?.water) || 0;
            const hardware = Number(expense[0]?.hardware) || 0;
            const infrastructure = Number(expense[0]?.infrastructure) || 0;
            const miscellaneous = Number(expense[0]?.miscellaneous) || 0;
            const total = hardware + infrastructure + miscellaneous + electricity + water;

            SetValueInHTMLById('electricity-usage', electricity);
            SetValueInHTMLById('water-usage', water);
            SetValueInHTMLById('expense-hardware', hardware);
            SetValueInHTMLById('expense-infrastructure', infrastructure);
            SetValueInHTMLById('expense-miscellaneous', miscellaneous);
            SetValueInHTMLById('expense-total', total);
        } catch (err) {
            console.error('âŒ loadSensorData error:', err);
        }

    }

    async function Card3() {
        console.log("Card 3");
        try {
        } catch (err) {
            console.error('âŒ loadSensorData error:', err);
        }

    }

    async function Card4() {
        console.log("Card 4");
        try {

        } catch (err) {
            console.error('âŒ loadSensorData error:', err);
        }
    }


    let sensorChart = null;
    let trendChart = null;

    async function loadGraphSensorById(sensors) {
        const loading = document.getElementById('do-loading');
        const title = document.getElementById('title-graph-sensor');
        const Subtitle = document.getElementById('title-graph-sensor-sub');

        try {
            const data = Object.values(sensors).find(
                s => s.monitor_id.toString() === sensor_select.toString()
            );

            if (!data || !data.logs || data.logs.length === 0) {
                console.warn('âš ï¸ à¹„à¸¡à¹ˆà¸¡à¸µà¸‚à¹‰à¸­à¸¡à¸¹à¸¥ ' + (data?.monitor_name ?? ''));

                if (sensorChart) {
                    updateSensorChart([], []);
                } else {
                    renderSensorChart([], []);
                }
                title.textContent = "à¸à¸£à¸²à¸Ÿà¹à¸ªà¸”à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸‚à¸­à¸‡ " + data?.monitor_name ?? "";
                Subtitle.textContent = "Historical " + data.monitor_name + " Data";
                return;
            }

            title.textContent = "à¹à¸™à¸§à¹‚à¸™à¹‰à¸¡à¸„à¹ˆà¸² " + data.monitor_name;
            Subtitle.textContent = "Historical " + data.monitor_name + " Data";

            const labels = data.logs.map(p => {
                const d = new Date(p.createtime);
                return `${d.getHours().toString().padStart(2, '0')}:${d.getMinutes().toString().padStart(2, '0')}`;
            });

            const values = data.logs.map(p => parseFloat(p.data_value));
            let min = Math.min(...values);
            let max = Math.max(...values);

            min = min - (min * 0.05);
            max = max + (max * 0.05);

            // ðŸ‘‡ à¸ˆà¸¸à¸”à¸ªà¸³à¸„à¸±à¸
            if (!sensorChart) {
                renderSensorChart(labels, values, min, max);
            } else {
                updateSensorChart(labels, values, min, max);
            }

        } catch (err) {
            console.error('âŒ loadDoTrendData error:', err);

            if (sensorChart) {
                updateSensorChart([], []);
            } else {
                renderSensorChart([], []);
            }

        } finally {
            if (loading) loading.classList.add('hidden');
        }
    }

    function renderSensorChart(labels, values, min = 0, max = 1) {
        const ctx = document.getElementById('TrendChart');
        if (!ctx) return;

        if (sensorChart) {
            sensorChart.destroy();
        }

        // Adjust font sizes based on screen width
        const screenWidth = window.innerWidth;
        let fontSize = 9;
        if (screenWidth >= 3840) fontSize = 18;
        else if (screenWidth >= 1920) fontSize = 12;

        sensorChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    // label: 'DO (mg/L)',
                    data: values,
                    borderColor: '#ff8021',
                    backgroundColor: 'rgba(255,128,33,0.1)',
                    tension: 0.4,
                    fill: true,
                    pointRadius: screenWidth >= 3840 ? 4 : 2,
                    pointBackgroundColor: '#ff8021'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: ctx => ` ${ctx.parsed.y.toFixed(2)} mg/L`
                        }
                    }
                },
                scales: {
                    x: {
                        grid: {
                            display: false
                        },
                        ticks: {
                            font: {
                                size: fontSize
                            },
                            color: '#78716c',
                            maxRotation: 0,
                            autoSkip: true,
                            maxTicksLimit: 8
                        }
                    },
                    y: {
                        beginAtZero: true,
                        min: min,
                        max: max,
                        ticks: {
                            font: {
                                size: fontSize
                            },
                            color: '#78716c',
                            callback: v => v.toFixed(1)
                        },
                        grid: {
                            color: 'rgba(0,0,0,0.05)'
                        }
                    }
                }
            }
        });
    }

    function updateSensorChart(labels, values, min, max) {
        sensorChart.data.labels = labels;
        sensorChart.data.datasets[0].data = values;
        sensorChart.options.scales.y.min = min
        sensorChart.options.scales.y.max = max
        sensorChart.update();
    }

    async function loadGraphMarketById() {
        const loading = document.getElementById('price-loading');
        const label = document.getElementById('types-MarketChart');

        try {

            const res = await fetch('../../api-website/market_trades.php?market=' + market_name + '&type=' + type);
            const raw = await res.json();
            const data = raw.data;

            if (!data || typeof data !== 'object') {
                console.warn('âš ï¸ à¹„à¸¡à¹ˆà¸¡à¸µà¸‚à¹‰à¸­à¸¡à¸¹à¸¥');
                renderMarketPriceChart([], []);
                return;
            }

            label.textContent = type;
            const types = type.split(',');  // ["demand","price"]

            // 1ï¸âƒ£ à¸£à¸§à¸¡à¸§à¸±à¸™à¸—à¸µà¹ˆà¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”
            let allDates = new Set();

            types.forEach(t => {
                if (Array.isArray(data[t])) {
                    data[t].forEach(r => allDates.add(r.trend_date));
                }
            });

            // 2ï¸âƒ£ à¹€à¸£à¸µà¸¢à¸‡à¸§à¸±à¸™à¸—à¸µà¹ˆ
            const labels = Array.from(allDates).sort();

            // 3ï¸âƒ£ à¸ªà¸£à¹‰à¸²à¸‡ datasets
            const datasets = types.map(t => {
                const mapByDate = {};
                if (Array.isArray(data[t])) {
                    data[t].forEach(r => {
                        mapByDate[r.trend_date] = Number(r.trend_value);
                    });
                }

                return {
                    label: t,
                    data: labels.map(date => mapByDate[date] ?? null),
                    borderWidth: 2,
                    fill: false,
                    spanGaps: true,
                    tension: 0.3,
                    borderColor: '#ff8021',
                    backgroundColor: 'rgba(255,128,33,0.15)',
                    pointRadius: screenWidth >= 3840 ? 5 : 2.5
                };
            });

            // 4ï¸âƒ£ à¸„à¸³à¸™à¸§à¸“ min/max à¸£à¸§à¸¡
            const allValues = datasets.flatMap(d => d.data).filter(v => v !== null);

            let min = Math.min(...allValues);
            let max = Math.max(...allValues);

            min -= min * 0.05;
            max += max * 0.05;

            min = Number(min.toFixed(2));
            max = Number(max.toFixed(2));

            renderMarketPriceChart(labels, datasets, min, max);

        } catch (err) {
            console.error('âŒ price trend error:', err);
        } finally {
            if (loading) loading.classList.add('hidden');
        }
    }

    function renderMarketPriceChart(labels, datasets, min = 0, max = 1) {
        const ctx = document.getElementById('marketPriceChart');
        if (!ctx) return;

        if (trendChart) {
            trendChart.destroy();
        }


        trendChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: ctx => ` ${ctx.raw}`
                        }
                    }
                },
                scales: {
                    x: {
                        grid: {
                            display: false
                        },
                        ticks: {
                            font: {
                                size: fontSize
                            },
                            color: '#78716c'
                        }
                    },
                    y: {
                        max: max,
                        min: min,
                        ticks: {
                            font: {
                                size: fontSize
                            },
                            color: '#78716c',
                            callback: v => v + ' à¸¿'
                        }
                    }
                }
            }
        });
    }

    function updateMarketPriceChart(labels, values, min = 0, max = 1) {
        trendChart.data.labels = labels;
        trendChart.data.datasets[0].data = values;
        trendChart.options.scales.y.min = min
        trendChart.options.scales.y.max = max
        trendChart.update();
    }

</script>