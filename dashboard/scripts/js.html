<!-- JavaScript -->
<script>
    let diff = { 'day': 0 };
    const thaiMonths = ['à¸¡à¸à¸£à¸²à¸„à¸¡', 'à¸à¸¸à¸¡à¸ à¸²à¸žà¸±à¸™à¸˜à¹Œ', 'à¸¡à¸µà¸™à¸²à¸„à¸¡', 'à¹€à¸¡à¸©à¸²à¸¢à¸™', 'à¸žà¸¤à¸©à¸ à¸²à¸„à¸¡', 'à¸¡à¸´à¸–à¸¸à¸™à¸²à¸¢à¸™', 'à¸à¸£à¸à¸Žà¸²à¸„à¸¡', 'à¸ªà¸´à¸‡à¸«à¸²à¸„à¸¡', 'à¸à¸±à¸™à¸¢à¸²à¸¢à¸™', 'à¸•à¸¸à¸¥à¸²à¸„à¸¡', 'à¸žà¸¤à¸¨à¸ˆà¸´à¸à¸²à¸¢à¸™', 'à¸˜à¸±à¸™à¸§à¸²à¸„à¸¡'];
    const today = new Date();
    const formattedDate = `${today.getDate()} ${thaiMonths[today.getMonth()]} ${today.getFullYear() + 543}`;
    document.getElementById('start-date').textContent = formattedDate;

    const screenWidth = window.innerWidth;
    const screenHeight = window.innerHeight;
    let fontSize = 10;
    if (screenWidth >= 3840) fontSize = 20;
    else if (screenWidth >= 1920) fontSize = 14;

    document.addEventListener('DOMContentLoaded', async () => {
        await setAmountDay();
    })

    async function setAmountDay() {
        const res = await fetch('../../api-website/fetch_amountDay.php?bid=1');
        const data = await res.json();
        diff = data['data'];
        const daydiff = document.getElementById("day-age");
        if (!daydiff) {
            console.warn("[warning] Not found Element id : day-age for set value");
            return;
        }
        daydiff.textContent = diff.day;
    }


    function getStatusByKey(key, v, min, max) {
        if (v >= min && v <= max) return { text: 'à¸”à¸µà¸—à¸µà¹ˆà¸ªà¸¸à¸”', type: 'success' };
        if (v > max) return { text: 'à¹€à¸«à¸¡à¸²à¸°à¸ªà¸¡', type: 'success' };
        if (v >= min && v <= max) return { text: 'à¹„à¸¡à¹ˆà¸”à¸µ', type: 'warning' };
        return { text: 'à¸­à¸±à¸™à¸•à¸£à¸²à¸¢', type: 'danger' };

    }

    function setBadge(statusEl, text, type) {
        const map = {
            success: 'status px-2 py-0.5 rounded-full bg-green-100 text-green-600 text-[1vw] font-bold uppercase',
            warning: 'status px-2 py-0.5 rounded-full bg-yellow-100 text-yellow-700 text-[1vw] font-bold uppercase',
            danger: 'status px-2 py-0.5 rounded-full bg-red-100 text-red-600 text-[1vw] font-bold uppercase',
            info: 'status px-2 py-0.5 rounded-full bg-blue-100 text-blue-700 text-[1vw] font-bold uppercase',
            na: 'status px-2 py-0.5 rounded-full bg-stone-100 text-stone-500 text-[1vw] font-bold uppercase',
            orange: 'status px-2 py-0.5 rounded-full bg-orange-100 text-orange-700 text-[1vw] font-bold uppercase',
        };

        statusEl.textContent = text;
        statusEl.className = map[type] || map.na;
    }

    function setCardValue(key, value, min, max) {
        const card = document.getElementById(`card-${key}`);
        if (!card) return;

        const valueEl = card.querySelector('.value');
        const statusEl = card.querySelector('.status');


        if (value === null || value === undefined || isNaN(value)) {
            valueEl.textContent = '--';
            setBadge(statusEl, 'N/A', 'na');
            return;
        }

        const v = Number(value);


        valueEl.textContent = v.toLocaleString('en-US', {
            minimumFractionDigits: 0,
            maximumFractionDigits: 2
        });

        const st = getStatusByKey(key, v, min, max);
        setBadge(statusEl, st.text, st.type);

        updateMetricBar(key, v);
    }

    //=============== Bar Process ==================

    function initMetricBars() {
        document.querySelectorAll('.metric-range').forEach(wrap => {
            const key = wrap.dataset.key;
            const min = wrap.dataset.min;
            const max = wrap.dataset.max;
            // const cfg = BAR_CONFIG[key];

            wrap.classList.remove('hidden');

            const left = wrap.querySelector('.label-left');
            const right = wrap.querySelector('.label-right');
            left.textContent = min || '';
            right.textContent = max || '';
            left.style.color = '#C73434';
            right.style.color = '#198754';

            const fill = wrap.querySelector('.fill');
            if (fill) fill.style.clipPath = 'inset(0 100% 0 0)';
        });
    }

    function updateMetricBar(key, value) {
        // const cfg = BAR_CONFIG[key];
        // if (!cfg) return;

        const wrap = document.querySelector(`.metric-range[data-key="${key}"]`);
        if (!wrap) return;

        const min = wrap.dataset.min;
        const max = wrap.dataset.max;

        const fill = wrap.querySelector('.fill');

        if (value === null || value === undefined || isNaN(value)) {
            if (fill) fill.style.clipPath = 'inset(0 100% 0 0)';
            return;
        }

        const v = Number(value);
        const pct = ((v - min) / (max - min)) * 100;
        const safePct = clamp(pct, 0, 100);

        if (fill) {
            // fill.style.clipPath = `inset(0 ${100 - safePct}% 0 0)`;
            fill.style.clipPath = `inset(0 50% 0 0)`;
        }
    }

    //=============== Function Calc ==================
    function clamp(n, min, max) {
        return Math.max(min, Math.min(max, n));
    }

    function toNumber(v) {
        const n = parseFloat(v);
        return Number.isFinite(n) ? n : 0;
    }

    function formatNumber(n) {
        return (Number.isFinite(n) ? n : 0).toFixed(1);
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    function Min(list) {
        if (!Array.isArray(list)) return 0;
        let min = Math.min(list);
        return min;
    }

    function Max(list) {
        if (!Array.isArray(list)) return 0;
        let max = Math.max(list);
        return max;
    }

    function Avg(list) {
        if (!Array.isArray(list)) return 0;
        const avg = (Sum(list) / list.length).toFixed(2);
        return avg;
    }

    function Sum(list) {
        if (!Array.isArray(list)) return 0;
        let sum = 0;
        list.forEach(v => {
            sum += v;
        });
        return sum;
    }

    function SetValueInHTMLById(id, value) {
        const div = document.getElementById(id);
        if (!div) {
            console.warn("SetValueInHTMLById \"id\" is wrong! (" + id + ")");
            return;
        }
        if ('value' in div) {
            div.value = value;
        } else {
            div.innerText = value;
        }
    }
    function setCard(side, index, title = "-", value = "-") {
        const base = `card-${side}-${index}`;
        SetValueInHTMLById(`${base}-title`, title);
        SetValueInHTMLById(`${base}-value`, value);
    }

    function SetCardsBynames(names, sensors, side) {
        Object.values(names).forEach((sensorName, index) => {

            if (!sensors || !sensors[sensorName]) {
                setCard(side, index + 1, sensorName, "-");
                return;
            }
            const sensor = sensors[sensorName];

            const latestValue = sensor.logs?.[0]?.data_value ?? "-";
            const textValue = latestValue == 1 ? "ON" : "OFF";

            setCard(side, index + 1, sensorName, textValue);
        });
    }


    function showPopup(id) {
        const div = document.getElementById(id);
        if (!div) return console.warn("à¹„à¸¡à¹ˆà¸žà¸š ID : " + id);

        div.classList.remove('hidden');
    }

    function hidePopup(id) {
        const div = document.getElementById(id);
        if (!div) return console.warn("à¹„à¸¡à¹ˆà¸žà¸š ID : " + id);

        div.classList.add('hidden');
    }






    // ============================= Graph ============================
    let sensorChart = null;
    let trendChart = null;

    async function loadGraphSensorById(sensors) {
        const loading = document.getElementById('do-loading');
        const title = document.getElementById('title-graph-sensor');
        const Subtitle = document.getElementById('title-graph-sensor-sub');

        try {
            const data = Object.values(sensors).find(
                s => s.monitor_id.toString() === sensor_select.toString()
            );

            if (!data || !data.logs || data.logs.length === 0) {
                console.warn('âš ï¸ à¹„à¸¡à¹ˆà¸¡à¸µà¸‚à¹‰à¸­à¸¡à¸¹à¸¥ ' + (data?.monitor_name ?? ''));

                if (sensorChart) {
                    updateSensorChart([], []);
                } else {
                    renderSensorChart([], []);
                }
                title.textContent = "à¸à¸£à¸²à¸Ÿà¹à¸ªà¸”à¸‡à¸‚à¹‰à¸­à¸¡à¸¹à¸¥à¸‚à¸­à¸‡" + data?.monitor_name ?? "";
                Subtitle.textContent = "Historical " + data?.monitor_name + " Data";
                return;
            }

            title.textContent = "à¹à¸™à¸§à¹‚à¸™à¹‰à¸¡à¸„à¹ˆà¸² " + data.monitor_name;
            Subtitle.textContent = "Historical " + data.monitor_name + " Data";

            const labels = data.logs.map(p => {
                const d = new Date(p.createtime);
                return `${d.getHours().toString().padStart(2, '0')}:${d.getMinutes().toString().padStart(2, '0')}`;
            });

            const values = data.logs.map(p => parseFloat(p.data_value));
            let min = Math.min(...values);
            let max = Math.max(...values);

            min = min - (min * 0.05);
            max = max + (max * 0.05);

            // ðŸ‘‡ à¸ˆà¸¸à¸”à¸ªà¸³à¸„à¸±à¸
            if (!sensorChart) {
                renderSensorChart(labels, values, min, max);
            } else {
                updateSensorChart(labels, values, min, max);
            }

        } catch (err) {
            console.error('âŒ loadDoTrendData error:', err);

            if (sensorChart) {
                updateSensorChart([], []);
            } else {
                renderSensorChart([], []);
            }

        } finally {
            if (loading) loading.classList.add('hidden');
        }
    }

    function renderSensorChart(labels, values, min = 0, max = 1) {
        const ctx = document.getElementById('TrendChart');
        if (!ctx) return;

        if (sensorChart) {
            sensorChart.destroy();
        }

        // Adjust font sizes based on screen width
        const screenWidth = window.innerWidth;
        let fontSize = 9;
        if (screenWidth >= 3840) fontSize = 18;
        else if (screenWidth >= 1920) fontSize = 12;

        sensorChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: labels,
                datasets: [{
                    // label: 'DO (mg/L)',
                    data: values,
                    borderColor: '#ff8021',
                    backgroundColor: 'rgba(255,128,33,0.1)',
                    tension: 0.4,
                    fill: true,
                    pointRadius: screenWidth >= 3840 ? 4 : 2,
                    pointBackgroundColor: '#ff8021'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: ctx => ` ${ctx.parsed.y.toFixed(2)} mg/L`
                        }
                    }
                },
                scales: {
                    x: {
                        grid: {
                            display: false
                        },
                        ticks: {
                            font: {
                                size: fontSize
                            },
                            color: '#78716c',
                            maxRotation: 0,
                            autoSkip: true,
                            maxTicksLimit: 8
                        }
                    },
                    y: {
                        beginAtZero: true,
                        min: min,
                        max: max,
                        ticks: {
                            font: {
                                size: fontSize
                            },
                            color: '#78716c',
                            callback: v => v.toFixed(1)
                        },
                        grid: {
                            color: 'rgba(0,0,0,0.05)'
                        }
                    }
                }
            }
        });
    }

    function updateSensorChart(labels, values, min, max) {
        sensorChart.data.labels = labels;
        sensorChart.data.datasets[0].data = values;
        sensorChart.options.scales.y.min = min
        sensorChart.options.scales.y.max = max
        sensorChart.update();
    }

    async function loadGraphMarketById() {
        const loading = document.getElementById('price-loading');
        const label = document.getElementById('types-MarketChart');

        try {

            const res = await fetch('../../api-website/market_trades.php?market=' + market_name + '&type=' + type);
            const raw = await res.json();
            const data = raw.data;

            if (!data || typeof data !== 'object') {
                console.warn('âš ï¸ à¹„à¸¡à¹ˆà¸¡à¸µà¸‚à¹‰à¸­à¸¡à¸¹à¸¥');
                renderMarketPriceChart([], []);
                return;
            }

            label.textContent = type;
            const types = type.split(',');  // ["demand","price"]

            // 1ï¸âƒ£ à¸£à¸§à¸¡à¸§à¸±à¸™à¸—à¸µà¹ˆà¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”
            let allDates = new Set();

            types.forEach(t => {
                if (Array.isArray(data[t])) {
                    data[t].forEach(r => allDates.add(r.trend_date));
                }
            });

            // 2ï¸âƒ£ à¹€à¸£à¸µà¸¢à¸‡à¸§à¸±à¸™à¸—à¸µà¹ˆ
            const labels = Array.from(allDates).sort();

            // 3ï¸âƒ£ à¸ªà¸£à¹‰à¸²à¸‡ datasets
            const datasets = types.map(t => {
                const mapByDate = {};
                if (Array.isArray(data[t])) {
                    data[t].forEach(r => {
                        mapByDate[r.trend_date] = Number(r.trend_value);
                    });
                }

                return {
                    label: t,
                    data: labels.map(date => mapByDate[date] ?? null),
                    borderWidth: 2,
                    fill: false,
                    spanGaps: true,
                    tension: 0.3,
                    borderColor: '#ff8021',
                    backgroundColor: 'rgba(255,128,33,0.15)',
                    pointRadius: screenWidth >= 3840 ? 5 : 2.5
                };
            });

            // 4ï¸âƒ£ à¸„à¸³à¸™à¸§à¸“ min/max à¸£à¸§à¸¡
            const allValues = datasets.flatMap(d => d.data).filter(v => v !== null);

            let min = Math.min(...allValues);
            let max = Math.max(...allValues);

            min -= min * 0.05;
            max += max * 0.05;

            min = Number(min.toFixed(2));
            max = Number(max.toFixed(2));

            renderMarketPriceChart(labels, datasets, min, max);

        } catch (err) {
            console.error('âŒ price trend error:', err);
        } finally {
            if (loading) loading.classList.add('hidden');
        }
    }

    function renderMarketPriceChart(labels, datasets, min = 0, max = 1) {
        const ctx = document.getElementById('marketPriceChart');
        if (!ctx) return;

        if (trendChart) {
            trendChart.destroy();
        }


        trendChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        callbacks: {
                            label: ctx => ` ${ctx.raw}`
                        }
                    }
                },
                scales: {
                    x: {
                        grid: {
                            display: false
                        },
                        ticks: {
                            font: {
                                size: fontSize
                            },
                            color: '#78716c'
                        }
                    },
                    y: {
                        max: max,
                        min: min,
                        ticks: {
                            font: {
                                size: fontSize
                            },
                            color: '#78716c',
                            callback: v => v + ' à¸¿'
                        }
                    }
                }
            }
        });
    }

    function updateMarketPriceChart(labels, values, min = 0, max = 1) {
        trendChart.data.labels = labels;
        trendChart.data.datasets[0].data = values;
        trendChart.options.scales.y.min = min
        trendChart.options.scales.y.max = max
        trendChart.update();
    }
</script>